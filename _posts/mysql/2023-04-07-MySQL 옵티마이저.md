---
layout: post  
title: 옵티마이저  
author: jae-hee Han  
date: 2023-04-07 23:00:00 +09:00  
categories: [MYSQL]  
tags: [mysql, 옵티마이저]  
math: true  
mermaid: true  
image: /assets/img/mysql.png  
path:   
lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA  
alt:
---

## 옵티마이저
현재 대부분의 DBMS는 비용 기반 최적화(Cost-based optimizer, CBO) 

### 풀 테이블 스캔
테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. 
백그라운드 스레드를 의해 **리드 어헤드(Read ahead)** 빨리 읽을 수 있다.

리드 어헤드 : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측하고 요청이 오기 전에 
미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것

### 풀 인덱스 스캔
```sql
mysql> SELECT count(*) FROM employees;
```
단순히 레코드 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문  
2~3개 컬럼만 구성되기 때문에 테이블 자체 보다는 용량이 작아서 훨씬 빠른 처리 가능

### 병렬 처리 
MySQL 8.0 에서는 innodb_parallel_read_threads 라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.

병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다. 

### ORDER BY 처리 (Using filesort)

<table style="width: 100%">
<tr>
  <td style="width: 20%">-</td>
  <td style="width: 40%">장점</td>
  <td style="width: 40%">단점</td>
</tr>
<tr>
  <td>인덱스 이용</td>
  <td>INSERT, UPDATE, DELETE 쿼리가 실행될 때<br/>이미 인덱스가 정렬돼 있어서 순서대로 읽기만<br/>하면 되므로 매우 빠르다.
  </td>
  <td>INSERT, UPDATE, DELETE 작업 시 부가적인<br/>인덱스 추가/삭제 작업이 필요하므로 느리다.<br/>인덱스 때문에 디스크 공간이 더 많이 필요하다.<br/>인덱스의 개수가 늘어날수록 InnoDB의 버퍼풀을<br/>위한 메모리가 많이 필요하다.</td>
</tr>
</table>


