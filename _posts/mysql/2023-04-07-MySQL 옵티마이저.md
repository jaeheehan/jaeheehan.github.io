---
layout: post  
title: 옵티마이저  
author: jae-hee Han  
date: 2023-04-07 23:00:00 +09:00  
categories: [MYSQL]  
tags: [mysql, 옵티마이저]  
math: true  
mermaid: true  
image: /assets/img/mysql.png  
path:   
lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA  
alt:
---

## 옵티마이저
현재 대부분의 DBMS는 비용 기반 최적화(Cost-based optimizer, CBO) 

### 풀 테이블 스캔
테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다. 
백그라운드 스레드를 의해 **리드 어헤드(Read ahead)** 빨리 읽을 수 있다.

리드 어헤드 : 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측하고 요청이 오기 전에 
미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것

### 풀 인덱스 스캔
```sql
mysql> SELECT count(*) FROM employees;
```
단순히 레코드 건수만 필요로 하는 쿼리라면 용량이 작은 인덱스를 선택하는 것이 디스크 읽기 횟수를 줄일 수 있기 때문  
2~3개 컬럼만 구성되기 때문에 테이블 자체 보다는 용량이 작아서 훨씬 빠른 처리 가능

### 병렬 처리 
MySQL 8.0 에서는 innodb_parallel_read_threads 라는 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지 변경할 수 있다.

병렬 처리용 스레드 개수를 아무리 늘리더라도 서버에 장착된 CPU의 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다. 

### ORDER BY 처리 (Using filesort)

<table style="width: 100%">
<tr>
  <td style="width: 20%">-</td>
  <td style="width: 40%">장점</td>
  <td style="width: 40%">단점</td>
</tr>
<tr>
  <td>인덱스 이용</td>
  <td>INSERT, UPDATE, DELETE 쿼리가 실행될 때<br/>이미 인덱스가 정렬돼 있어서 순서대로 읽기만<br/>하면 되므로 매우 빠르다.
  </td>
  <td>INSERT, UPDATE, DELETE 작업 시 부가적인<br/>인덱스 추가/삭제 작업이 필요하므로 느리다.<br/>인덱스 때문에 디스크 공간이 더 많이 필요하다.<br/>인덱스의 개수가 늘어날수록 InnoDB의 버퍼풀을<br/>위한 메모리가 많이 필요하다.</td>
</tr>
<tr>
  <td>Filesort 이용</td>
  <td>인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때<br/>의 단점이 장점으로 바뀐다.<br/>정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort<br/>가 처리되므로 충분히 빠르다.
  </td>
  <td>정렬작업이 쿼리 실행시 처리되므로 레코드 대상<br/> 건수가 많아질수도록 쿼리 응답속도가 느리다.</td>
</tr>
</table>

MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 "Using filesort" 메시지가 표시되는지 여부로 판단할 수 있다.

### 소트버퍼

MySQL은 정렬을 수행하기 위해 별도의 메모리 공간을 할당받아서 사용하는데 이 메모리 공간을 소트 버퍼(Sort buffer) 라고 한다. 쿼리 실행이 완료되면 즉시 시스템으로 반납된다.

정렬해야 할 레코드의 건수가 소트버퍼로 할당된 공간보다 크다면 여러조각으로 나눠서 처리하는데 **임시 저장을 위해 디스크**를 사용 

소트버퍼 크게 설정해서 빠른 성능을 얻을 수도 있지만 시스템 메모리 부족으로 MySQL 서버가 종료될 위험이 있다. 

### 정렬 알고리즘





